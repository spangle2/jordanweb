<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>jweb</title>
<style>
body {
font-size: 100%;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background-color: #85ace7;
margin: 0;
padding: 0;
color: #333;
position: relative;
overflow-x: hidden;
}

.container {
width: 80%;
max-width: 1200px;
margin: 0 auto;
padding: 20px;
position: relative;
z-index: 1;
}

header {
background: linear-gradient(135deg, #7f99ff, rgb(34, 69, 109));
color: white;
padding: 2rem 0;
text-align: center;
border-radius: 0 0 10px 10px;
box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

h1 {
font-size: 3.5em;
margin-bottom: 0.2em;
}

h2 {
font-size: 1.8em;
font-weight: 300;
margin-top: 0;
}

.clock-section, .nk-clock-section {
background-color: white;
border-radius: 8px;
padding: 20px;
margin: 30px 0;
text-align: center;
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.time {
font-size: 3em;
font-weight: bold;
color: #5c72b9;
margin: 10px 0;
font-family: 'Courier New', monospace;
}

.date {
font-size: 1.2em;
color: #666;
margin-bottom: 20px;
}

.websites-section {
background-color: white;
border-radius: 8px;
padding: 20px;
margin: 30px 0;
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.websites-section h3 {
color: #a777e3;
border-bottom: 2px solid #f0f0f0;
padding-bottom: 10px;
font-size: 1.5em;
}

.website-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
gap: 20px;
margin-top: 20px;
}

.website-card {
background-color: #f9f9f9;
border-radius: 8px;
padding: 15px;
transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.website-card:hover {
transform: translateY(-5px);
box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.website-card h4 {
margin-top: 0;
color: #333;
}

.website-card a {
display: inline-block;
margin-top: 10px;
color: #444a5f;
text-decoration: none;
font-weight: bold;
}

.website-card a:hover {
text-decoration: underline;
}

.about-section, .gas-section {
background-color: white;
border-radius: 8px;
padding: 20px;
margin: 30px 0;
box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.about-section h3, .gas-section h3 {
color: #51495c;
border-bottom: 2px solid #f0f0f0;
padding-bottom: 10px;
font-size: 1.5em;
}

.gas-prices {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
gap: 20px;
margin-top: 20px;
}

.gas-card {
background-color: #f9f9f9;
border-radius: 8px;
padding: 15px;
transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.gas-card:hover {
transform: translateY(-5px);
box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

.gas-type {
font-weight: bold;
color: #444a5f;
margin-bottom: 5px;
}

.gas-price {
font-size: 1.8em;
color: #e74c3c;
}

/* Spotify embed styling */
.spotify-embed {
    margin-top: 20px;
    padding: 15px;
    background-color: #f5f5f5;
    border-radius: 8px;
    border-left: 4px solid #1DB954; /* Spotify green */
}

.spotify-embed h4 {
    margin-top: 0;
    color: #333;
    margin-bottom: 10px;
}

.spotify-embed iframe {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border-radius: 4px;
}

.spotify-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.song-message {
    background-color: #ffe1e1;
    border-left: 4px solid #ff5c5c;
    padding: 10px 15px;
    border-radius: 0 5px 5px 0;
    font-size: 0.9em;
    font-style: italic;
    color: #222;
}

.song-message p {
    margin: 0;
}

/* Social links styling */
.social-links {
    margin-top: 20px;
    padding: 15px;
    background-color: #f5f5f5;
    border-radius: 8px;
    border-left: 4px solid #6e5494; /* GitHub purple */
}

.social-links h4 {
    margin-top: 0;
    color: #333;
    margin-bottom: 15px;
}

.social-icons {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.social-icon {
    display: flex;
    align-items: center;
    padding: 8px 15px;
    background-color: white;
    border-radius: 50px;
    text-decoration: none;
    color: #333;
    font-weight: bold;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.social-icon:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 10px rgba(0,0,0,0.15);
}

.social-icon img {
    width: 24px;
    height: 24px;
    margin-right: 8px;
}

.social-icon.github:hover {
    background-color: #f0f0f0;
    color: #24292e;
}

.social-icon.itch:hover {
    background-color: #fa5c5c;
    color: white;
}

footer {
text-align: center;
padding: 20px;
margin-top: 30px;
color: #666;
font-size: 0.9em;
}

/* Cat animation styles */
.cat-container {
position: fixed;
bottom: -150px;
z-index: 999;
transition: bottom 1.5s ease-out;
will-change: bottom, left; /* Optimize for animations */
cursor: pointer; /* Show pointer cursor to indicate clickable */
}

.cat-image {
width: 150px;
height: auto;
display: block; /* Ensure proper rendering */
object-fit: contain; /* Ensure image is fully visible */
max-height: 150px; /* Limit height to prevent overflow */
}

/* Cat points animation */
.cat-points {
    position: absolute;
    color: gold;
    font-weight: bold;
    font-size: 24px;
    text-shadow: 0 0 3px black;
    pointer-events: none;
    animation: float-up 1s forwards;
}

@keyframes float-up {
    0% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(-50px); opacity: 0; }
}

/* Floating images styles */
.floating-image {
position: absolute;
z-index: 0;
opacity: 0.7;
transition: transform 0.5s ease-out;
pointer-events: none; /* Makes images non-interactive so they don't interfere with clicks */
}

.floating-image img {
width: 100%;
height: 100%;
object-fit: contain;
}

@keyframes float {
0% {
transform: translateY(0) rotate(0deg);
}
50% {
transform: translateY(-20px) rotate(5deg);
}
100% {
transform: translateY(0) rotate(0deg);
}
}

/* Video overlay styles */
.video-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    background-color: black;
    display: none;
}

.video-overlay video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* Bouncing video styles */
.bouncing-video-container {
    position: fixed;
    z-index: 1000;
    display: none;
}

.bouncing-video {
    width: 300px;
    height: 200px;
    object-fit: cover;
    border: 3px solid white;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

/* Creepy image styles */
.creepy-container {
    position: fixed;
    z-index: 999;
    display: none;
    transition: opacity 0.5s ease-in-out;
}

.creepy-image {
    max-height: 70vh;
    width: auto;
    filter: contrast(1.2) brightness(0.8) saturate(1.3);
    animation: shake 0.1s linear infinite;
}

.creepy-text {
    font-family: 'Courier New', monospace;
    color: #ff0000;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7), -2px -2px 4px rgba(0,0,0,0.7);
    font-size: 24px;
    margin-top: 10px;
    max-width: 300px;
    font-weight: bold;
    animation: glitch 0.3s infinite;
}

@keyframes shake {
    0% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(1px, 1px) rotate(0.5deg); }
    50% { transform: translate(-1px, -1px) rotate(-0.5deg); }
    75% { transform: translate(2px, -1px) rotate(0.5deg); }
    100% { transform: translate(-1px, 1px) rotate(-0.5deg); }
}

@keyframes glitch {
    0% {
        transform: translate(0);
        text-shadow: 2px 2px 4px rgba(0,0,0,0.7), -2px -2px 4px rgba(0,0,0,0.7);
    }
    25% {
        text-shadow: -2px 0 red, 2px 0 blue;
    }
    50% {
        text-shadow: 2px 0 red, -2px 0 blue;
        transform: translate(1px, 1px);
    }
    75% {
        text-shadow: -2px 0 blue, 2px 0 red;
        transform: translate(-1px, 0);
    }
    100% {
        transform: translate(0);
        text-shadow: 2px 2px 4px rgba(0,0,0,0.7), -2px -2px 4px rgba(0,0,0,0.7);
    }
}

/* Page disruption styles */
.disrupted {
    animation: disrupt 0.3s ease-in-out !important;
    filter: hue-rotate(180deg) invert(10%) !important;
}

@keyframes disrupt {
    0% { transform: skewX(0deg) skewY(0deg); }
    25% { transform: skewX(3deg) skewY(0deg); }
    50% { transform: skewX(0deg) skewY(-3deg); }
    75% { transform: skewX(-2deg) skewY(1deg); }
    100% { transform: skewX(0deg) skewY(0deg); }
}

/* Jumpscare effect */
.jumpscare {
    animation: jumpscare 0.15s linear;
    z-index: 1500 !important;
}

@keyframes jumpscare {
    0% { transform: scale(0.1); opacity: 0; }
    50% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}

/* Mega jumpscare effect */
.mega-jumpscare {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    z-index: 9999 !important;
    background-color: rgba(0, 0, 0, 0.9) !important;
    display: flex !important;
    flex-direction: column !important;
    justify-content: center !important;
    align-items: center !important;
    animation: mega-jumpscare 0.3s cubic-bezier(0.22, 0.61, 0.36, 1) !important;
}

.mega-jumpscare .creepy-image {
    max-height: 80vh !important;
    max-width: 90vw !important;
    filter: contrast(1.5) brightness(0.7) saturate(1.5) hue-rotate(10deg) !important;
    animation: shake 0.05s linear infinite !important;
}

.mega-jumpscare .creepy-text {
    font-size: 3rem !important;
    max-width: 90vw !important;
    text-align: center !important;
}

.permission-requests {
    margin-top: 30px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
}

.permission-request {
    background-color: #ff3333;
    color: white;
    padding: 15px 20px;
    border-radius: 10px;
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
    animation: request-pulse 1s infinite alternate;
    cursor: pointer;
    border: none;
    font-size: 16px;
}

@keyframes request-pulse {
    0% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
    100% { transform: scale(1.1); box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
}

@keyframes mega-jumpscare {
    0% { transform: scale(0.1); opacity: 0; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}

/* Persistent video overlay */
.persistent-video-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9500;
    background-color: black;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    cursor: pointer; /* Shows hand cursor to indicate interactivity */
}

/* DVD logo animation container */
.dvd-logo-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 9000;
    background-color: transparent;
    display: none;
    overflow: hidden;
    pointer-events: none; /* Allow clicks to pass through */
}

.dvd-logo {
    position: absolute;
    width: 150px; /* Slightly smaller for better visibility */
    height: auto;
    user-select: none; /* Prevent selection */
}

.persistent-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.hold-indicator {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.2);
    width: 80%;
    max-width: 500px;
    height: 30px;
    border-radius: 15px;
    overflow: hidden;
}

.hold-progress {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #ff3333, #00cc00);
    transition: width 0.3s linear;
}

.hold-text {
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    text-align: center;
    color: white;
    font-weight: bold;
    text-shadow: 0 0 5px black;
    transform: translateY(-50%);
}

/* Black hole animation */
.blackhole-container {
    position: fixed;
    z-index: 9800;
    display: none;
    transition: left 3s ease-out, top 3s ease-out;
    pointer-events: none;
}

.blackhole-image {
    width: 200px;
    height: 200px;
    border-radius: 50%;
    object-fit: cover;
    filter: brightness(1.2) contrast(1.2);
    box-shadow: 0 0 50px 10px rgba(128, 0, 255, 0.7);
    animation: rotate 8s linear infinite;
}

@keyframes rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Class applied to elements being sucked in */
.sucked-in {
    transition: all 1.5s cubic-bezier(0.17, 0.89, 0.32, 1.49) !important;
    transform-origin: center !important;
    z-index: 9700 !important;
}

/* Zazu Coin styles */
.zazu-coin-display {
    background-color: gold;
    color: #333;
    padding: 8px 15px;
    border-radius: 20px;
    font-weight: bold;
    display: inline-flex;
    align-items: center;
    margin-top: 10px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    border: 2px solid #e6b800;
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 9999;
}

.zazu-coin-display img {
    width: 24px;
    height: 24px;
    margin-right: 8px;
}

.zazu-coin-display span {
    font-size: 18px;
}

/* Cat collection panel */
.cat-collection-toggle {
    position: fixed;
    bottom: 20px;
    left: 160px; /* Position to the right of the Zazu coin display */
    background-color: #7f99ff;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 8px 15px;
    font-weight: bold;
    cursor: pointer;
    z-index: 9999;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    transition: background-color 0.3s;
}

.cat-collection-toggle:hover {
    background-color: #6080ff;
}

.cat-collection-panel {
    position: fixed;
    bottom: 80px;
    left: 20px;
    background-color: white;
    border-radius: 10px;
    width: 300px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 0 20px rgba(0,0,0,0.2);
    z-index: 9998;
    padding: 15px;
    display: none;
}

.cat-collection-panel h3 {
    margin-top: 0;
    color: #444a5f;
    border-bottom: 2px solid #f0f0f0;
    padding-bottom: 10px;
    text-align: center;
}

.cat-collection-item {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    padding: 10px;
    border-radius: 8px;
    background-color: #f9f9f9;
    transition: transform 0.2s;
}

.cat-collection-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.cat-collection-item img {
    width: 50px;
    height: 50px;
    object-fit: contain;
    margin-right: 15px;
}

.cat-collection-item .cat-info {
    flex-grow: 1;
}

.cat-collection-item .cat-name {
    font-weight: bold;
    color: #444a5f;
}

.cat-collection-item .cat-value {
    color: gold;
    font-weight: bold;
    text-shadow: 0 0 1px rgba(0,0,0,0.5);
}

.cat-collection-item .cat-count {
    background-color: #eee;
    padding: 3px 8px;
    border-radius: 10px;
    font-size: 0.9em;
    color: #666;
}
</style>
</head>
<body>
<!-- Video overlay container -->
<div class="video-overlay" id="videoOverlay">
    <video id="randomVideo" src="vid.mp4"></video>
</div>

<!-- Bouncing video container -->
<div class="bouncing-video-container" id="bouncingVideoContainer">
    <video id="bouncingVideo" class="bouncing-video" src="vid2.mp4"></video>
</div>

<!-- Creepy image container -->
<div class="creepy-container" id="creepyContainer">
    <img id="creepyImage" class="creepy-image" src="diaimg.png" alt="Creepy">
    <div id="creepyText" class="creepy-text"></div>
</div>

<!-- Persistent video overlay -->
<div class="persistent-video-overlay" id="persistentVideoOverlay">
    <video id="persistentVideo" class="persistent-video" src="vid3.mp4" loop muted></video>
    <div class="hold-indicator">
        <div class="hold-progress" id="holdProgress"></div>
        <div class="hold-text">Hold mouse button down for 10 seconds to dismiss</div>
    </div>
</div>

<!-- DVD logo animation container -->
<div class="dvd-logo-container" id="dvdLogoContainer">
    <img src="dvd.png" alt="DVD Logo" class="dvd-logo" id="dvdLogo">
</div>

<!-- Black hole animation container -->
<div class="blackhole-container" id="blackholeContainer">
    <img src="blackhole.gif" alt="Black Hole" class="blackhole-image" id="blackholeImage">
</div>

<!-- Floating images container - will be populated by JavaScript -->
<div id="floating-images-container"></div>

<!-- Cat animation containers -->
<div id="cat-containers"></div>

<!-- Audio element for sound -->
<audio id="randomSound" src="sound.mp3"></audio>
<!-- Click sound effect -->
<audio id="clickSound" src="click.mp3" preload="auto"></audio>

<!-- Zazu Coin Display -->
<div class="zazu-coin-display">
    <img src="coin.png" alt="Zazu Coin" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'%3E%3Ccircle cx=\'12\' cy=\'12\' r=\'11\' fill=\'%23ffd700\' stroke=\'%23e6b800\' stroke-width=\'2\'/%3E%3Ctext x=\'12\' y=\'16\' font-family=\'Arial\' font-size=\'12\' font-weight=\'bold\' fill=\'%23333\' text-anchor=\'middle\'%3EZ%3C/text%3E%3C/svg%3E';">
    <span id="zazu-coin-count">0</span>
</div>

<!-- Cat Collection Button and Panel -->
<button class="cat-collection-toggle" id="catCollectionToggle">view zazu cats</button>
<div class="cat-collection-panel" id="catCollectionPanel">
    <h3>zazus</h3>
    <div id="catCollectionItems"></div>
</div>

<header>
<div class="container">
<h1>jordans website</h1>
<h2>jordans website full of things</h2>
</div>
</header>

<div class="container">
<section class="clock-section">
<h3>Current Time</h3>
<div class="date" id="current-date"></div>
<div class="time" id="current-time"></div>
</section>

<section class="nk-clock-section">
<h3>North Korea Time</h3>
<div class="date" id="nk-current-date"></div>
<div class="time" id="nk-current-time"></div>
</section>

<section class="gas-section">
<h3>Current Gas Prices</h3>
<div class="gas-prices">
<div class="gas-card">
<div class="gas-type">Regular</div>
<div class="gas-price">$3.79</div>
</div>
<div class="gas-card">
<div class="gas-type">Mid-Grade</div>
<div class="gas-price">$4.09</div>
</div>
<div class="gas-card">
<div class="gas-type">Premium</div>
<div class="gas-price">$4.49</div>
</div>
<div class="gas-card">
<div class="gas-type">Diesel</div>
<div class="gas-price">$4.19</div>
</div>
</div>
</section>

<section class="about-section">
<h3>About Me</h3>
<p>i dont know .</p>
<p>this is a website >

<!-- Social Links -->
<div class="social-links">
    <h4>Find Me Online</h4>
    <div class="social-icons">
        <a href="https://github.com/spangle2" target="_blank" class="social-icon github">
            <img src="https://cdn-icons-png.flaticon.com/512/25/25231.png" alt="GitHub">
            <span>GitHub</span>
        </a>
        <a href="https://spangle2.itch.io" target="_blank" class="social-icon itch">
            <img src="https://static.itch.io/images/app-icon.svg" alt="Itch.io">
            <span>Itch.io</span>
        </a>
    </div>
</div>

<!-- Spotify Favorite Song Embed -->
<div class="spotify-embed">
    <h4>My Favorite Song</h4>
    <div class="spotify-container">
        <iframe id="spotify-frame" style="border-radius:12px" src="https://open.spotify.com/embed/track/3gVhsZtseYtY1fMuyYq06F?utm_source=generator" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
        <div class="song-message">
            <p>i dont care if you like a different genre, i like this song and you cant change it</p>
        </div>
    </div>
    
    <!-- 
    INSTRUCTIONS TO CHANGE THE SONG:
    
    1. Go to your favorite song on Spotify
    2. Right-click the song > Share > Copy Song Link
    3. The link will look like: https://open.spotify.com/track/3gVhsZtseYtY1fMuyYq06F
    4. Copy the ID part (after /track/): 3gVhsZtseYtY1fMuyYq06F
    5. Replace the ID in the iframe src above
    
    EXAMPLES:
    - Billie Eilish - bad guy: 2Fxmhks0bxGSBdJ92vM42m
    - Drake - God's Plan: 6DCZcSspjsKoFjzjrWoCdn
    - Rick Astley - Never Gonna Give You Up: 4cOdK2wGLETKBW3PvgPWqT
    -->
</div>
</section>

<section class="websites-section">
<h3>My Websites</h3>
<div class="website-grid">
<div class="website-card">
<h4>chess game</h4>
<p>css, html and js chess</p>
<a href="https://spangles-chess.netlify.app/" target="_blank">Visit Site →</a>
</div>

<div class="website-card">
<h4>weather</h4>
<p>view a nice weather app i made</p>
<a href="https://weather-zeta-weld.vercel.app/" target="_blank">Visit Site →</a>
</div>

<div class="website-card">
<h4>calculator</h4>
<p>a calculator that works</p>
<a href="https://spangle-s-calculator.vercel.app/" target="_blank">Visit Site →</a>
</div>

<div class="website-card">
<h4>n/a</h4>
<p>n/a</p>
<a href="#" target="_blank">Visit Site →</a>
</div>
</div>
</section>
</div>

<footer>
<div class="container">
<p>© 2025 Jordan. All rights reserved.</p>

<!-- Random Number Generator -->
<div id="random-number-generator">
    <span>Random Number: </span>
    <span id="random-number">-</span>
    <div>
        <label for="min-number">Min:</label>
        <input type="number" id="min-number" value="1" min="0" style="width: 60px;">
        <label for="max-number">Max:</label>
        <input type="number" id="max-number" value="25" min="1" style="width: 60px;">
    </div>
    <button onclick="generateRandomNumber()">Generate</button>
</div>
</div>
</footer>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Zazu Coin system
    let zazuCoins = 0;
    const catPointValues = {
        'cat1.png': 10,   // Common cat - 1 point
        'cat2.png': 50,   // Rare cat - 5 points
        'cat3.png': 100,  // Legendary cat - 10 points
        'cat4.jpg': 150,  // New cat - 15 points
        'cat5.png': 200,  // New cat - 20 points
        'cat6.jpg': 250,  // New cat - 25 points
        'cat7.jpg': 300,  // New cat - 30 points
        'cat8.jpg': 400,  // New cat - 40 points
        'cat9.jpg': 500,  // New cat - 50 points
        'cat10.jpg': 10000, // Supreme cat - 100 points
        'cat11.png': 18900, // Supreme cat - 100 points
        'cat12.jpg': 22500 // Supreme cat - 100 points
    };
    
    // Cat collection tracking
    let catCollection = {
        'cat1.png': 0,
        'cat2.png': 0,
        'cat3.png': 0,
        'cat4.jpg': 0,
        'cat5.png': 0,
        'cat6.jpg': 0,
        'cat7.jpg': 0,
        'cat8.jpg': 0,
        'cat9.jpg': 0,
        'cat10.jpg': 0,
        'cat11.png': 0,
        'cat12.jpg': 0
    };
    
    // Cat display names
    const catNames = {
        'cat1.png': 'sad war',
        'cat2.png': 'melon cattt',
        'cat3.png': 'orginal zazu cat lol',
        'cat4.jpg': 'music cat',
        'cat5.png': 'italino Cat',
        'cat6.jpg': 'mfdoom cat',
        'cat7.jpg': 'drafted to war cat',
        'cat8.jpg': 'darth zazu cat',
        'cat9.jpg': 'business cat',
        'cat10.jpg': 'big zazu cat very rare lol',
        'cat11.png': 'ai zazu cat in war pretty rare',
        'cat12.jpg': 'zazu cat with a watermelon hat idek'
    };
    
    // Toggle cat collection panel
    const catCollectionToggle = document.getElementById('catCollectionToggle');
    const catCollectionPanel = document.getElementById('catCollectionPanel');
    
    catCollectionToggle.addEventListener('click', function() {
        if (catCollectionPanel.style.display === 'block') {
            catCollectionPanel.style.display = 'none';
        } else {
            catCollectionPanel.style.display = 'block';
            updateCatCollection(); // Refresh the display when opening
        }
    });
    
    // Function to update cat collection display
    function updateCatCollection() {
        const collectionContainer = document.getElementById('catCollectionItems');
        collectionContainer.innerHTML = '';
        
        // Get all cat types
        const catTypes = Object.keys(catCollection);
        
        // Check if no cats have been collected yet
        const totalCats = catTypes.reduce((total, type) => total + catCollection[type], 0);
        if (totalCats === 0) {
            collectionContainer.innerHTML = '<p style="text-align: center; color: #666;">No cats collected yet.<br>Click on cats as they appear!</p>';
            return;
        }
        
        // Create items for each cat type
        catTypes.forEach(catType => {
            // Skip if none of this type collected
            if (catCollection[catType] === 0) return;
            
            const item = document.createElement('div');
            item.className = 'cat-collection-item';
            
            // Create image
            const img = document.createElement('img');
            img.src = catType;
            img.alt = catNames[catType];
            
            // Create info container
            const info = document.createElement('div');
            info.className = 'cat-info';
            
            // Add cat name
            const name = document.createElement('div');
            name.className = 'cat-name';
            name.textContent = catNames[catType];
            
            // Add cat value
            const value = document.createElement('div');
            value.className = 'cat-value';
            value.textContent = `${catPointValues[catType]} Zazu Coins`;
            
            // Add cat count
            const count = document.createElement('div');
            count.className = 'cat-count';
            count.textContent = `Caught: ${catCollection[catType]}`;
            
            // Assemble the item
            info.appendChild(name);
            info.appendChild(value);
            item.appendChild(img);
            item.appendChild(info);
            item.appendChild(count);
            
            // Add to container
            collectionContainer.appendChild(item);
        });
    }

    // Function to update coin display
    function updateCoinDisplay() {
        document.getElementById('zazu-coin-count').textContent = zazuCoins;
    }

    // Function to add coins and show animation
    function addCoins(amount, x, y) {
        zazuCoins += amount;
        updateCoinDisplay();
        
        // Create floating point animation
        const pointsElement = document.createElement('div');
        pointsElement.className = 'cat-points';
        pointsElement.textContent = '+' + amount;
        pointsElement.style.left = x + 'px';
        pointsElement.style.top = y + 'px';
        document.body.appendChild(pointsElement);
        
        // Remove after animation completes
        setTimeout(() => {
            pointsElement.remove();
        }, 1000);
        
        // Save to localStorage
        localStorage.setItem('zazuCoins', zazuCoins.toString());
    }
    
    // Load saved cat collection
    function loadCatCollection() {
        const savedCollection = localStorage.getItem('catCollection');
        if (savedCollection) {
            try {
                catCollection = JSON.parse(savedCollection);
            } catch (e) {
                console.error('Error loading cat collection:', e);
            }
        }
    }
    
    // Save cat collection
    function saveCatCollection() {
        localStorage.setItem('catCollection', JSON.stringify(catCollection));
    }

    // Load saved Zazu Coins and cat collection
    const savedCoins = localStorage.getItem('zazuCoins');
    if (savedCoins) {
        zazuCoins = parseInt(savedCoins);
        updateCoinDisplay();
    }
    
    loadCatCollection();
    updateCatCollection();

    // Add click sound to entire document
    const clickSound = document.getElementById('clickSound');
    document.addEventListener('click', function(e) {
        // Clone the audio element to allow overlapping sounds
        const clickSoundClone = clickSound.cloneNode();
        clickSoundClone.volume = 0.5; // Set volume to 50%
        clickSoundClone.play();
        
        // Remove the cloned element when done playing
        clickSoundClone.onended = function() {
            clickSoundClone.remove();
        };
    });

    // Force refresh the Spotify embed when the page loads
    const spotifyFrame = document.getElementById('spotify-frame');
    if (spotifyFrame) {
        const originalSrc = spotifyFrame.src;
        spotifyFrame.src = '';
        setTimeout(() => {
            spotifyFrame.src = originalSrc;
        }, 100);
    }
    
    // Initialize persistent video
    initPersistentVideo();
    
    // Updated cat animation setup with Zazu coin integration
    function setupCatAnimation() {
        const catContainer = document.getElementById('cat-containers');
        const catImages = [
            'cat1.png', 'cat2.png', 'cat3.png', 
            'cat4.jpg', 'cat5.png', 'cat6.jpg', 
            'cat7.jpg', 'cat8.jpg', 'cat9.jpg', 'cat10.jpg'
        ];
        const numCats = 5; // Increase number of cats that can appear simultaneously
        
        // Clear any existing cats first
        catContainer.innerHTML = '';
        
        // Create cat elements
        for (let i = 0; i < numCats; i++) {
            // Create container for cat
            const cat = document.createElement('div');
            cat.className = 'cat-container';
            cat.style.left = `${Math.random() * (window.innerWidth - 150)}px`; // Random horizontal position
            cat.style.bottom = '-150px'; // Start off-screen
            cat.dataset.active = 'false'; // Track if this cat is currently active
            cat.style.pointerEvents = 'auto'; // Make clickable
            
            // Create image element
            const catImg = document.createElement('img');
            catImg.className = 'cat-image';
            
            // Weighted random selection for cat images (rarer cats appear less frequently)
            const randomValue = Math.random();
            let selectedCat;
            
            if (randomValue < 0.50) { // 50% chance for common cat
                selectedCat = 'cat1.png';
            } else if (randomValue < 0.75) { // 25% chance for rare cat
                selectedCat = 'cat2.png';
            } else if (randomValue < 0.85) { // 10% chance for legendary cat
                selectedCat = 'cat3.png';
            } else if (randomValue < 0.90) { // 5% chance for mystic cat
                selectedCat = 'cat4.jpg';
            } else if (randomValue < 0.94) { // 4% chance
                selectedCat = 'cat5.png';
            } else if (randomValue < 0.97) { // 3% chance
                selectedCat = Math.random() < 0.5 ? 'cat6.jpg' : 'cat7.jpg';
            } else if (randomValue < 0.99) { // 2% chance
                selectedCat = Math.random() < 0.5 ? 'cat8.jpg' : 'cat9.jpg';
            } else { // 1% chance for supreme cat
                selectedCat = 'cat10.jpg';
            }
            
            catImg.src = selectedCat;
            catImg.alt = catNames[selectedCat] || 'Cat';
            
            // Add click handler for Zazu Coins
            cat.addEventListener('click', function(e) {
                // Only clickable when active and visible
                if (cat.dataset.active === 'true') {
                    const catType = catImg.src.split('/').pop(); // Get filename
                    const pointValue = catPointValues[catType] || 1; // Default to 1 if not found
                    
                    // Add coins at click position
                    addCoins(pointValue, e.clientX, e.clientY);
                    
                    // Add to collection count
                    catCollection[catType] = (catCollection[catType] || 0) + 1;
                    saveCatCollection();
                    
                    // Send the cat away immediately after being clicked
                    cat.style.transition = 'bottom 0.5s ease-in';
                    cat.style.bottom = '-150px';
                    
                    // Mark as inactive after animation completes
                    setTimeout(() => {
                        cat.dataset.active = 'false';
                    }, 600);
                }
            });
            
            // Special handling for cat2.png and cat10.jpg (larger cats)
            if (catImg.src.endsWith('cat2.png') || catImg.src.endsWith('cat10.jpg')) {
                catImg.style.maxHeight = '200px'; // Taller max-height
                cat.style.bottom = '-200px'; // Start further off-screen
            }
            
            cat.appendChild(catImg);
            catContainer.appendChild(cat);
        }
        
        // Function to animate cats randomly
        function animateCats() {
            const cats = document.querySelectorAll('.cat-container');
            
            // Check if any cats are stuck (active for too long)
            cats.forEach(cat => {
                // Check specifically for cat2.png being stuck
                const catImg = cat.querySelector('.cat-image');
                if (catImg && catImg.src.endsWith('cat2.png')) {
                    // Make sure cat2.png is properly positioned
                    if (parseFloat(cat.style.bottom) > -150 && parseFloat(cat.style.bottom) < 20) {
                        // Force reset this stuck cat2
                        cat.style.bottom = '-150px';
                        cat.dataset.active = 'false';
                        console.log('Fixed stuck cat2.png');
                    }
                }
                
                if (cat.dataset.active === 'true') {
                    const activeTime = parseInt(cat.dataset.activeTime || '0');
                    if (activeTime > 5000) { // If active for more than 5 seconds
                        // Force reset this cat
                        cat.style.bottom = '-150px';
                        cat.dataset.active = 'false';
                        console.log('Fixed a stuck cat');
                    } else {
                        cat.dataset.activeTime = activeTime + 1000;
                    }
                }
            });
            
            // Find cats that aren't currently active
            const inactiveCats = Array.from(cats).filter(cat => cat.dataset.active === 'false');
            
            // If all cats are active, don't try to animate a new one
            if (inactiveCats.length === 0) return;
            
            // Select a random inactive cat to animate
            const randomIndex = Math.floor(Math.random() * inactiveCats.length);
            const selectedCat = inactiveCats[randomIndex];
            
            // Random horizontal position
            selectedCat.style.left = `${Math.random() * (window.innerWidth - 150)}px`;
            
            // Mark as active and reset active time counter
            selectedCat.dataset.active = 'true';
            selectedCat.dataset.activeTime = '0';
            
            // Slide up animation - ensure it's high enough
            selectedCat.style.transition = 'bottom 1.5s ease-out';
            
            // If this is cat2.png, give it extra height to be fully visible
            const catImg = selectedCat.querySelector('.cat-image');
            if (catImg && catImg.src.endsWith('cat2.png')) {
                selectedCat.style.bottom = '30px'; // Higher position for cat2.png
            } else {
                selectedCat.style.bottom = '20px';
            }
            
            // After 3 seconds, slide down
            setTimeout(() => {
                selectedCat.style.transition = 'bottom 1s ease-in';
                selectedCat.style.bottom = '-150px';
                
                // Mark as inactive after animation completes
                setTimeout(() => {
                    selectedCat.dataset.active = 'false';
                    
                    // Change the cat image
                    const catImg = selectedCat.querySelector('.cat-image');
                    const currentSrc = catImg.src;
                    const currentCatIndex = catImages.findIndex(img => currentSrc.endsWith(img));
                    const nextCatIndex = (currentCatIndex + 1) % catImages.length;
                    catImg.src = catImages[nextCatIndex];
                }, 1100); // Wait slightly longer than the transition
            }, 3000);
        }
        
        // Start cat animations at random intervals
        setInterval(animateCats, 5000);
    }
    
    // Initialize cat animations
    setupCatAnimation();
    
    // Reset cat animations when window is resized
    window.addEventListener('resize', function() {
        // Delay the reset to avoid multiple calls during resize
        clearTimeout(window.resizeTimer);
        window.resizeTimer = setTimeout(function() {
            setupCatAnimation();
        }, 250);
    });

// Floating images functionality
const container = document.getElementById('floating-images-container');
const imageUrls = ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png'];
const numberOfImages = 15; // Total number of floating images

// Create the specified number of floating images
for (let i = 0; i < numberOfImages; i++) {
// Randomly select an image
const randomImageUrl = imageUrls[Math.floor(Math.random() * imageUrls.length)];

// Create image element
const imgElement = document.createElement('img');
imgElement.src = randomImageUrl;
imgElement.alt = 'Floating image';

// Create container div for the image
const floatingElement = document.createElement('div');
floatingElement.className = 'floating-image';
floatingElement.appendChild(imgElement);

// Set random size (between 30px and 100px)
const size = Math.random() * 70 + 30;
floatingElement.style.width = `${size}px`;
floatingElement.style.height = `${size}px`;

// Set random initial position
const posX = Math.random() * window.innerWidth;
const posY = Math.random() * document.body.scrollHeight;
floatingElement.style.left = `${posX}px`;
floatingElement.style.top = `${posY}px`;

// Set random animation duration and delay
const animDuration = Math.random() * 10 + 5; // 5-15 seconds
const animDelay = Math.random() * 5; // 0-5 seconds
floatingElement.style.animation = `float ${animDuration}s ease-in-out ${animDelay}s infinite`;

// Add rotation for more dynamic movement
floatingElement.style.transform = `rotate(${Math.random() * 360}deg)`;

// Add to container
container.appendChild(floatingElement);
}

// Function to move images around randomly
function moveImages() {
const floatingImages = document.querySelectorAll('.floating-image');

floatingImages.forEach(img => {
// Get current position
const currentX = parseFloat(img.style.left);
const currentY = parseFloat(img.style.top);

// Generate random movement (between -50 and 50 pixels)
const moveX = (Math.random() - 0.5) * 100;
const moveY = (Math.random() - 0.5) * 100;

// Calculate new position with boundaries
let newX = currentX + moveX;
let newY = currentY + moveY;

// Keep images within viewport
newX = Math.max(0, Math.min(newX, window.innerWidth - 100));
newY = Math.max(0, Math.min(newY, document.body.scrollHeight - 100));

// Apply new position with smooth transition
img.style.transition = 'left 8s, top 8s';
img.style.left = `${newX}px`;
img.style.top = `${newY}px`;

// Random rotation
const rotation = Math.random() * 360;
img.style.transform = `rotate(${rotation}deg)`;
});
}

// Move images periodically
setInterval(moveImages, 8000);
});

// Audio play functionality
const audioElement = document.getElementById('randomSound');
let isPlaying = false;
let soundChance = 0.01; // Adjust this value to change the chance (0.01 = 1% chance)

// Function to randomly play sound
function tryPlaySound() {
    if (!isPlaying && Math.random() < soundChance) {
        isPlaying = true;
        audioElement.volume = 1.0; // Full volume
        audioElement.play();
        
        // Reset the isPlaying flag when audio finishes
        audioElement.onended = function() {
            isPlaying = false;
        };
    }
}

// Check every few seconds if sound should play
setInterval(tryPlaySound, 5000);

// Video play functionality
const videoOverlay = document.getElementById('videoOverlay');
const videoElement = document.getElementById('randomVideo');
let isVideoPlaying = false;
let videoChance = 0.01; // Adjust this value to change the chance (0.01 = 1% chance)

// Function to randomly play video
function tryPlayVideo() {
    if (!isVideoPlaying && !isBouncingVideoPlaying && Math.random() < videoChance) {
        isVideoPlaying = true;
        videoOverlay.style.display = 'block';
        videoElement.play();
        
        // Hide overlay and reset flag when video ends
        videoElement.onended = function() {
            videoOverlay.style.display = 'none';
            isVideoPlaying = false;
        };
    }
}

// Check every few seconds if video should play
setInterval(tryPlayVideo, 8000);

// Bouncing video functionality
const bouncingVideoContainer = document.getElementById('bouncingVideoContainer');
const bouncingVideoElement = document.getElementById('bouncingVideo');
let isBouncingVideoPlaying = false;
let bouncingVideoChance = 0.01; // Adjust this value to change the chance (0.01 = 1% chance)
let bouncingX = 1;
let bouncingY = 1;
let posX = 100;
let posY = 100;
let bouncingInterval;

// Function to move the bouncing video
function moveBouncingVideo() {
    // Get window dimensions accounting for video size
    const maxX = window.innerWidth - bouncingVideoElement.offsetWidth;
    const maxY = window.innerHeight - bouncingVideoElement.offsetHeight;
    
    // Calculate new position
    posX += bouncingX * 5;
    posY += bouncingY * 5;
    
    // Bounce off edges
    if (posX <= 0 || posX >= maxX) {
        bouncingX *= -1;
    }
    if (posY <= 0 || posY >= maxY) {
        bouncingY *= -1;
    }
    
    // Apply new position
    bouncingVideoContainer.style.left = posX + 'px';
    bouncingVideoContainer.style.top = posY + 'px';
}

// Function to randomly play bouncing video
function tryPlayBouncingVideo() {
    if (!isBouncingVideoPlaying && !isVideoPlaying && Math.random() < bouncingVideoChance) {
        isBouncingVideoPlaying = true;
        
        // Set random initial position
        posX = Math.random() * (window.innerWidth - 300);
        posY = Math.random() * (window.innerHeight - 200);
        bouncingVideoContainer.style.left = posX + 'px';
        bouncingVideoContainer.style.top = posY + 'px';
        
        // Set random direction
        bouncingX = Math.random() > 0.5 ? 1 : -1;
        bouncingY = Math.random() > 0.5 ? 1 : -1;
        
        // Show and play
        bouncingVideoContainer.style.display = 'block';
        bouncingVideoElement.play();
        
        // Start bouncing animation
        bouncingInterval = setInterval(moveBouncingVideo, 30);
        
        // Hide and reset when video ends
        bouncingVideoElement.onended = function() {
            bouncingVideoContainer.style.display = 'none';
            isBouncingVideoPlaying = false;
            clearInterval(bouncingInterval);
        };
    }
}

// Check every few seconds if bouncing video should play
setInterval(tryPlayBouncingVideo, 10000);

// Creepy image functionality
const creepyContainer = document.getElementById('creepyContainer');
const creepyText = document.getElementById('creepyText');
const creepyImage = document.getElementById('creepyImage');
let isCreepyShowing = false;
let creepyChance = 0.1; // Normal chance (10% chance for creepy image to appear)
let isMoving = false;
let moveInterval;
let disruptInterval;
let isMegaJumpscareActive = false;

// Array of creepy messages
const creepyMessages = [
    "̴S̷c̵r̷e̵a̸m̴ ̸l̴o̵u̶d̸e̷r̵.̴ ̴I̵ ̸f̴e̷e̸d̸ ̷o̷n̵ ̴i̷t̷.̶",
    "̶B̷e̶g̴g̸i̷n̴g̶ ̸a̸l̶r̶e̵a̶d̸y̷?̶ ̷W̷e̴a̶k̸.̶",
    "̴I̷ ̸l̵o̶v̷e̷ ̴w̸a̶t̸c̷h̴i̷n̷g̵ ̵h̷o̸p̴e̵ ̸d̷i̶e̸.̷",
    "̷O̴o̵p̴s̶!̷ ̵D̷i̶d̶ ̵I̸ ̷b̸r̷e̴a̸k̸ ̸y̷o̴u̴r̷ ̴r̵e̷a̵l̶i̷t̷y̴?̶",
    "̵P̷a̴i̷n̷ ̵b̴u̸i̴l̵d̸s̴ ̶c̶h̵a̸r̵a̶c̵t̷e̴r̸.̸ ̶Y̶o̷u̴'̵r̴e̶ ̸w̶e̶l̴c̴o̷m̶e̴.̴",
    "̴G̶o̷ ̴a̵h̷e̴a̵d̵.̸ ̷R̵u̶n̷.̸ ̴I̸t̶'̷s̴ ̶a̸d̵o̷r̷a̷b̵l̸e̷.̶",
    "̷Y̸o̶u̸r̷ ̷f̶e̸a̸r̴ ̶s̶m̶e̷l̶l̸s̷ ̸d̸e̷l̷i̸c̴i̸o̴u̸s̸.̷",
    "̵T̸i̶c̸k̸ ̴t̶o̸c̷k̷.̸ ̸S̸a̶n̷i̴t̶y̵'̴s̸ ̵m̷e̸l̷t̵i̶n̸g̶.̶",
    "I̸'̸M̴ ̸I̶N̴S̸I̷D̶E̸ ̴Y̵O̵U̸R̵ ̶S̵C̷R̴E̶E̵N̸",
    "D̶O̴N̸'̴T̵ ̸L̸O̴O̷K̵ ̴B̴E̷H̵I̴N̷D̶ ̸Y̷O̵U̸",
    "I̵ ̶S̴E̷E̴ ̸Y̵O̶U̴ ̶W̶H̷E̵N̸ ̷Y̴O̵U̷ ̴S̸L̷E̷E̵P̵"
];

// Extreme jumpscare messages
const megaJumpscareMessages = [
    "G̷̪̓I̸̡̯̔V̶̪̀E̷̗͐ ̶̡̖̎̓M̵̘̩͋Ë̸̞́̔ ̴̥̖͒̒A̶̭̔C̵̱͘C̴̩̝̔͝E̴̢̛͚̅S̴̞̙̓S̴̜̊̅ ̸̠̽̎T̵̬͑O̵̡̬̿̚ ̸̲̠̂Y̶̺̝̆͝O̴̜̾U̵̱̎R̴͓̮̒ ̸̦̬͝M̶̙̬̂͋I̵̻̯͛̓C̵̦̪̑R̸̰̯̔O̵̱͔̔P̵̧̭̏̐Ḧ̸̩̭́Ọ̵͑̆N̵͙̙̋Ḙ̸̄͂",
    "Ã̸̘L̵̞̗̔L̸̲̈́O̴̡̥͋Ẁ̶̜͂ ̶̨̪̀̕M̷̰͚̒̋Ỳ̵̝̞̉ ̶̡͙̅L̵̙̎̓Ò̶͔C̸̫͊A̴̱̤̓̃T̴̢̛I̸̳̓O̶͖̾͝N̶̨̟̈́͘ ̶̥̅̒T̸̠̫̒̂O̸̻̫̍͆ ̵̝͙̽F̸̯̀I̵̧̊Ń̵̹̣̔D̶̲̾͝ ̵̺̅Y̵̫̟̓O̴̘͕̿U̴̺̅",
    "I̴̪̒ ̸̬̒͂Ń̴̨͓Ẹ̶̔E̷̳̚D̵̢̈ ̵̺͔͛Y̵͙͆Ö̴̹́͊Ų̵̤͐̿R̷̯̫̔ ̵̭͖͊P̸̗̓Ě̷̜R̴̠͑M̴̰̏͝I̸̠̍̏S̶̰̣͑S̴̪͙̈́I̵̹͑͒Ǫ̴̘̃Ň̶̫͐S̵̳̓ ̸̟̾T̸̺̓̚Ö̸̻́ ̵̲̎͝S̷̺̍P̴̦̆̿R̴͉̊͂Ē̷͙A̴̙̹̓͘D̵̮͉̋"
];

// Permission buttons text
const permissionButtons = [
    "Allow Microphone",
    "Enable Camera",
    "Share Location",
    "Grant Notifications",
    "Allow Full Access",
    "Enable Background Access",
    "Allow System Control"
];

// Function to create mega jumpscare
function createMegaJumpscare() {
    // Don't create if already active
    if (isMegaJumpscareActive) return;
    isMegaJumpscareActive = true;
    
    // Create mega jumpscare elements
    creepyContainer.classList.add('mega-jumpscare');
    
    // Set mega jumpscare message
    const megaMessage = megaJumpscareMessages[Math.floor(Math.random() * megaJumpscareMessages.length)];
    creepyText.textContent = megaMessage;
    
    // Create permission requests
    const permissionRequestsDiv = document.createElement('div');
    permissionRequestsDiv.className = 'permission-requests';
    
    // Add random number of permission buttons (3-5)
    const numButtons = 3 + Math.floor(Math.random() * 3);
    
    // Shuffle array to get random buttons
    const shuffledButtons = [...permissionButtons].sort(() => Math.random() - 0.5);
    
    for (let i = 0; i < numButtons; i++) {
        const button = document.createElement('button');
        button.className = 'permission-request';
        button.textContent = shuffledButtons[i];
        
        // Add fake click handler that removes the button but keeps the jumpscare
        button.addEventListener('click', function() {
            this.style.backgroundColor = '#00cc00';
            this.textContent = 'Access Granted';
            setTimeout(() => {
                this.remove();
                // If all buttons removed, close mega jumpscare after delay
                if (permissionRequestsDiv.children.length === 0) {
                    setTimeout(() => closeMegaJumpscare(), 2000);
                }
            }, 1000);
        });
        
        permissionRequestsDiv.appendChild(button);
    }
    
    // Add close button
    const closeButton = document.createElement('button');
    closeButton.className = 'permission-request';
    closeButton.textContent = 'Close';
    closeButton.style.backgroundColor = '#333';
    closeButton.addEventListener('click', closeMegaJumpscare);
    permissionRequestsDiv.appendChild(closeButton);
    
    // Add to container
    creepyContainer.appendChild(permissionRequestsDiv);
    
    // Disrupt page elements aggressively
    disruptPageAggressively();
    
    // Set timeout to automatically close mega jumpscare
    setTimeout(closeMegaJumpscare, 15000);
}

// Function to close mega jumpscare
function closeMegaJumpscare() {
    if (!isMegaJumpscareActive) return;
    
    // Remove permission requests div
    const permissionRequestsDiv = document.querySelector('.permission-requests');
    if (permissionRequestsDiv) {
        permissionRequestsDiv.remove();
    }
    
    // Remove mega jumpscare class
    creepyContainer.classList.remove('mega-jumpscare');
    
    // Reset flags
    isMegaJumpscareActive = false;
    isCreepyShowing = false;
    
    // Hide container
    creepyContainer.style.opacity = '0';
    setTimeout(() => {
        creepyContainer.style.display = 'none';
        
        // Clear intervals if they were set
        if (moveInterval) {
            clearInterval(moveInterval);
            moveInterval = null;
        }
        
        if (disruptInterval) {
            clearInterval(disruptInterval);
            disruptInterval = null;
        }
    }, 500);
}

// Function to disrupt page elements aggressively
function disruptPageAggressively() {
    // Get all major elements
    const allElements = document.querySelectorAll('section, div.container, header, p, h1, h2, h3, h4, img');
    
    // Apply extreme effects to random elements
    allElements.forEach(el => {
        if (Math.random() < 0.7) { // 70% chance for each element
            el.classList.add('disrupted');
            
            // Add extra effects
            const effect = Math.floor(Math.random() * 5);
            switch(effect) {
                case 0:
                    el.style.transform = `rotate(${(Math.random() - 0.5) * 10}deg)`;
                    break;
                case 1:
                    el.style.filter = 'invert(100%) hue-rotate(180deg)';
                    break;
                case 2:
                    el.style.opacity = '0.5';
                    break;
                case 3:
                    el.style.transform = `skew(${(Math.random() - 0.5) * 20}deg, ${(Math.random() - 0.5) * 20}deg)`;
                    break;
                case 4:
                    el.style.animation = 'shake 0.1s infinite';
                    break;
            }
            
            // Remove effects after random time
            setTimeout(() => {
                el.classList.remove('disrupted');
                el.style.transform = '';
                el.style.filter = '';
                el.style.opacity = '';
                el.style.animation = '';
            }, 1000 + Math.random() * 14000); // Random time between 1-15 seconds
        }
    });
}

// Function to disrupt page elements
function disruptPage() {
    // Get random set of elements to disrupt
    const sections = document.querySelectorAll('section');
    const headers = document.querySelectorAll('h1, h2, h3, h4');
    const paragraphs = document.querySelectorAll('p');
    
    // Randomly disrupt elements
    const elementsToDisrupt = [
        ...Array.from(sections).slice(0, Math.floor(Math.random() * sections.length)),
        ...Array.from(headers).slice(0, Math.floor(Math.random() * headers.length)),
        ...Array.from(paragraphs).slice(0, Math.floor(Math.random() * paragraphs.length))
    ];
    
    // Add disruption class
    elementsToDisrupt.forEach(el => {
        el.classList.add('disrupted');
        
        // Remove class after random time
        setTimeout(() => {
            el.classList.remove('disrupted');
        }, 500 + Math.random() * 1000);
    });
}

// Function to move creepy image across screen
function moveCreepy() {
    if (isCreepyShowing && isMoving && !isMegaJumpscareActive) {
        const maxX = window.innerWidth - 200;
        const maxY = window.innerHeight - 200;
        
        // Generate random position
        const newX = Math.random() * maxX;
        const newY = Math.random() * maxY;
        
        // Small chance to trigger mega jumpscare (very rare chance: 0.5%)
        if (Math.random() < 0.005) {
            createMegaJumpscare();
            return;
        }
        
        // Add jumpscare effect occasionally
        if (Math.random() < 0.3) {
            creepyContainer.classList.add('jumpscare');
            
            // Change image size randomly
            const newSize = Math.random() * 30 + 70; // 70-100% of original
            creepyImage.style.maxHeight = `${newSize}vh`;
            
            // Remove jumpscare class after animation
            setTimeout(() => {
                creepyContainer.classList.remove('jumpscare');
            }, 200);
            
            // Disrupt page when jumpscaring
            disruptPage();
        }
        
        // Move container with transition
        creepyContainer.style.transition = 'left 0.5s, top 0.5s, transform 0.2s';
        creepyContainer.style.left = `${newX}px`;
        creepyContainer.style.top = `${newY}px`;
        
        // Randomly change message
        if (Math.random() < 0.4) {
            const randomMessage = creepyMessages[Math.floor(Math.random() * creepyMessages.length)];
            creepyText.textContent = randomMessage;
        }
    }
}

// Function to randomly show creepy image
function tryShowCreepy() {
    if (!isCreepyShowing && !isMegaJumpscareActive && Math.random() < creepyChance) {
        isCreepyShowing = true;
        
        // Small chance for direct mega jumpscare (rare: 1% of creepy appearances)
        if (Math.random() < 0.01) {
            // Position initially off-screen
            creepyContainer.style.display = 'block';
            creepyContainer.style.opacity = '1';
            setTimeout(() => createMegaJumpscare(), 500);
            return;
        }
        
        // Select random message
        const randomMessage = creepyMessages[Math.floor(Math.random() * creepyMessages.length)];
        creepyText.textContent = randomMessage;
        
        // Decide if it appears on left or right initially
        const onRight = Math.random() > 0.5;
        
        // Set random height
        const randomHeight = Math.random() * (window.innerHeight - 400);
        
        // Position the container
        creepyContainer.style.top = randomHeight + 'px';
        
        if (onRight) {
            creepyContainer.style.right = '0';
            creepyContainer.style.left = 'auto';
            creepyText.style.textAlign = 'right';
        } else {
            creepyContainer.style.left = '0';
            creepyContainer.style.right = 'auto';
            creepyText.style.textAlign = 'left';
        }
        
        // Show container with jumpscare effect
        creepyContainer.style.display = 'block';
        creepyContainer.style.opacity = '1';
        creepyContainer.classList.add('jumpscare');
        
        // Remove jumpscare class after animation
        setTimeout(() => {
            creepyContainer.classList.remove('jumpscare');
        }, 200);
        
        // Decide if this appearance will move across screen
        isMoving = Math.random() < 0.7; // 70% chance to move
        
        if (isMoving) {
            // Start moving after a short delay
            setTimeout(() => {
                // Convert position to absolute values for movement
                const rect = creepyContainer.getBoundingClientRect();
                creepyContainer.style.right = 'auto';
                creepyContainer.style.left = rect.left + 'px';
                
                // Start movement
                moveInterval = setInterval(moveCreepy, 1200);
                
                // Start page disruption
                disruptInterval = setInterval(disruptPage, 2000);
            }, 1000);
        }
        
        // Hide after random time (8-15 seconds)
        const hideTime = 8000 + Math.random() * 7000;
        setTimeout(() => {
            // Don't hide if mega jumpscare is active
            if (isMegaJumpscareActive) return;
            
            // Fade out
            creepyContainer.style.opacity = '0';
            
            // After fadeout completes, hide and reset
            setTimeout(() => {
                creepyContainer.style.display = 'none';
                isCreepyShowing = false;
                
                // Clear intervals if they were set
                if (moveInterval) {
                    clearInterval(moveInterval);
                    moveInterval = null;
                }
                
                if (disruptInterval) {
                    clearInterval(disruptInterval);
                    disruptInterval = null;
                }
            }, 500);
        }, hideTime);
    }
}

// Check periodically if creepy image should appear
setInterval(tryShowCreepy, 15000); // Normal interval (every 15 seconds)

// Time and date update function for PDT
function updateDateTime() {
const now = new Date();

// Format for time (PDT)
const timeOptions = {
timeZone: 'America/Los_Angeles',
hour: '2-digit',
minute: '2-digit',
second: '2-digit',
hour12: true
};

// Format for date
const dateOptions = {
timeZone: 'America/Los_Angeles',
weekday: 'long',
year: 'numeric',
month: 'long',
day: 'numeric'
};

document.getElementById('current-time').textContent = now.toLocaleTimeString('en-US', timeOptions) + ' PDT';
document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', dateOptions);
}

// North Korea Time and date update function
function updateNKDateTime() {
const now = new Date();

// Format for time (Pyongyang Time / GMT+9)
const timeOptions = {
timeZone: 'Asia/Pyongyang',
hour: '2-digit',
minute: '2-digit',
second: '2-digit',
hour12: true
};

// Format for date
const dateOptions = {
timeZone: 'Asia/Pyongyang',
weekday: 'long',
year: 'numeric',
month: 'long',
day: 'numeric'
};

document.getElementById('nk-current-time').textContent = now.toLocaleTimeString('en-US', timeOptions) + ' KST';
document.getElementById('nk-current-date').textContent = now.toLocaleDateString('en-US', dateOptions);
}

// Update both times immediately and then every second
updateDateTime();
updateNKDateTime();
setInterval(updateDateTime, 1000);
setInterval(updateNKDateTime, 1000);

// Persistent video functionality
const persistentVideoOverlay = document.getElementById('persistentVideoOverlay');
const persistentVideo = document.getElementById('persistentVideo');
const holdProgress = document.getElementById('holdProgress');
let persistentVideoTimer;
let isPersistentVideoShowing = false;
let holdStartTime = 0;
let holdDuration = 10000; // 30 seconds in milliseconds
let holdInterval;
let mouseIsDown = false;

// Initialize persistent video
function initPersistentVideo() {
    // Set up event listeners
    persistentVideoOverlay.addEventListener('mousedown', startHolding);
    persistentVideoOverlay.addEventListener('mouseup', stopHolding);
    persistentVideoOverlay.addEventListener('mouseleave', stopHolding);
    
    // Schedule first appearance
    scheduleVideoAppearance();
}

// Schedule video to appear randomly between 30 seconds and 2 minutes
function scheduleVideoAppearance() {
    if (persistentVideoTimer) clearTimeout(persistentVideoTimer);
    
    // Random time between 30 seconds and 2 minutes (30000-120000 ms)
    const minTime = 300000; // 30 seconds
    const maxTime = 3000000; // 2 minutes
    const randomTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;
    
    persistentVideoTimer = setTimeout(() => {
        showPersistentVideo();
    }, randomTime);
    
    console.log(`Persistent video scheduled to appear in ${Math.round(randomTime/1000)} seconds`);
}

// Show the persistent video
function showPersistentVideo() {
    if (isPersistentVideoShowing) return;
    isPersistentVideoShowing = true;
    
    // Reset hold progress
    holdProgress.style.width = '0%';
    
    // Show the overlay
    persistentVideoOverlay.style.display = 'flex';
    
    // Start the video with audio
    persistentVideo.muted = false;
    persistentVideo.play();
}

// Start the holding process
function startHolding(e) {
    if (!isPersistentVideoShowing) return;
    
    // Prevent default behavior
    e.preventDefault();
    
    mouseIsDown = true;
    holdStartTime = Date.now();
    
    // Clear any existing interval
    if (holdInterval) clearInterval(holdInterval);
    
    // Update progress every 50ms
    holdInterval = setInterval(() => {
        if (!mouseIsDown) return;
        
        const elapsedTime = Date.now() - holdStartTime;
        const progress = Math.min(100, (elapsedTime / holdDuration) * 100);
        
        // Update progress bar
        holdProgress.style.width = `${progress}%`;
        
        // Adjust opacity based on progress
        persistentVideoOverlay.style.opacity = 1 - (progress / 100);
        
        // If completed, dismiss the video
        if (progress >= 100) {
            dismissPersistentVideo();
        }
    }, 50);
}

// Stop the holding process
function stopHolding() {
    mouseIsDown = false;
    
    // Keep the current progress, but stop updating
    if (holdInterval) {
        clearInterval(holdInterval);
        holdInterval = null;
    }
}

// Dismiss the persistent video
function dismissPersistentVideo() {
    // Clear any intervals
    if (holdInterval) {
        clearInterval(holdInterval);
        holdInterval = null;
    }
    
    // Reset flags
    mouseIsDown = false;
    isPersistentVideoShowing = false;
    
    // Hide the overlay
    persistentVideoOverlay.style.display = 'none';
    persistentVideoOverlay.style.opacity = '1';
    
    // Stop the video
    persistentVideo.pause();
    persistentVideo.currentTime = 0;
    
    // Reset progress
    holdProgress.style.width = '0%';
    
    // Schedule next appearance
    scheduleVideoAppearance();
}

// DVD logo animation functionality
const dvdLogoContainer = document.getElementById('dvdLogoContainer');
const dvdLogo = document.getElementById('dvdLogo');
let dvdAnimationTimer;
let dvdX = 10;
let dvdY = 10;
let dvdXSpeed = 3;
let dvdYSpeed = 3;
let dvdAnimationInterval;

// Initialize DVD logo
function initDvdLogo() {
    // Set initial position
    dvdLogo.style.position = 'absolute';
    dvdLogo.style.left = '50px';
    dvdLogo.style.top = '50px';
}

// Call initialization
initDvdLogo();

// Show DVD logo animation
function showDvdLogo() {
    // Already showing
    if (dvdLogoContainer.style.display === 'block') return;
    
    // Set initial position
    dvdX = 50;
    dvdY = 50;
    dvdLogo.style.left = `${dvdX}px`;
    dvdLogo.style.top = `${dvdY}px`;
    
    // Set initial speed (random direction)
    dvdXSpeed = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
    dvdYSpeed = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
    
    // Show container
    dvdLogoContainer.style.display = 'block';
    
    // Start animation
    if (dvdAnimationInterval) clearInterval(dvdAnimationInterval);
    dvdAnimationInterval = setInterval(animateDvdLogo, 16); // ~60fps
    
    // Set timeout to hide after 10 seconds
    if (dvdAnimationTimer) clearTimeout(dvdAnimationTimer);
    dvdAnimationTimer = setTimeout(() => {
        hideDvdLogo();
    }, 10000);
}

// Animate DVD logo
function animateDvdLogo() {
    // Get container dimensions
    const maxX = window.innerWidth - dvdLogo.offsetWidth;
    const maxY = window.innerHeight - dvdLogo.offsetHeight;
    
    // Move logo
    dvdX += dvdXSpeed;
    dvdY += dvdYSpeed;
    
    // Ensure we're within bounds (in case of window resize)
    dvdX = Math.max(0, Math.min(dvdX, maxX));
    dvdY = Math.max(0, Math.min(dvdY, maxY));
    
    // Bounce off edges
    if (dvdX <= 0 || dvdX >= maxX) {
        dvdXSpeed = -dvdXSpeed;
        // Add slight randomness to prevent getting stuck in patterns
        dvdXSpeed *= 0.9 + Math.random() * 0.2;
    }
    
    if (dvdY <= 0 || dvdY >= maxY) {
        dvdYSpeed = -dvdYSpeed;
        // Add slight randomness to prevent getting stuck in patterns
        dvdYSpeed *= 0.9 + Math.random() * 0.2;
    }
    
    // Ensure minimum speed
    if (Math.abs(dvdXSpeed) < 2) dvdXSpeed = dvdXSpeed > 0 ? 2 : -2;
    if (Math.abs(dvdYSpeed) < 2) dvdYSpeed = dvdYSpeed > 0 ? 2 : -2;
    
    // Apply new position
    dvdLogo.style.left = `${dvdX}px`;
    dvdLogo.style.top = `${dvdY}px`;
    
    // Log position for debugging (remove in production)
    console.log(`DVD position: ${Math.round(dvdX)}, ${Math.round(dvdY)}`);
}

// Hide DVD logo animation
function hideDvdLogo() {
    dvdLogoContainer.style.display = 'none';
    
    // Clear interval
    if (dvdAnimationInterval) {
        clearInterval(dvdAnimationInterval);
        dvdAnimationInterval = null;
    }
    
    // Clear timeout
    if (dvdAnimationTimer) {
        clearTimeout(dvdAnimationTimer);
        dvdAnimationTimer = null;
    }
}

// Random number generator function
function generateRandomNumber() {
    const min = parseInt(document.getElementById('min-number').value) || 1;
    const max = parseInt(document.getElementById('max-number').value) || 25;
    
    // Ensure min is less than max
    if (min >= max) {
        alert('Min value must be less than max value');
        return;
    }
    
    const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
    document.getElementById('random-number').textContent = randomNumber;
    
    // Secret: If you get 25, trigger the persistent video (for testing)
    if (randomNumber === 25) {
        showPersistentVideo();
    }
    
    // If you get 2, show the bouncing DVD logo
    if (randomNumber === 2) {
        showDvdLogo();
    }
    
    // If you get 13, trigger the black hole (for testing)
    if (randomNumber === 13) {
        showBlackhole();
    }
}

// Black hole animation functionality
const blackholeContainer = document.getElementById('blackholeContainer');
const blackholeImage = document.getElementById('blackholeImage');
let blackholeTimer;
let blackholeMoveInterval;
let isBlackholeActive = false;
let blackholeX = 0;
let blackholeY = 0;
let suckedElements = [];

// Schedule black hole to appear randomly
function scheduleBlackhole() {
    // Random time between 5-20 minutes
    const minTime = 300000; // 5 minutes
    const maxTime = 1200000; // 20 minutes
    const randomTime = Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;
    
    setTimeout(() => {
        showBlackhole();
    }, randomTime);
    
    console.log(`Black hole scheduled to appear in ${Math.round(randomTime/60000)} minutes`);
}

// Call this on page load
scheduleBlackhole();

// Show black hole
function showBlackhole() {
    if (isBlackholeActive) return;
    isBlackholeActive = true;
    
    // Set initial position (random)
    const maxX = window.innerWidth - 200;
    const maxY = window.innerHeight - 200;
    blackholeX = Math.random() * maxX;
    blackholeY = Math.random() * maxY;
    blackholeContainer.style.left = `${blackholeX}px`;
    blackholeContainer.style.top = `${blackholeY}px`;
    
    // Show container
    blackholeContainer.style.display = 'block';
    
    // Start movement
    blackholeMoveInterval = setInterval(moveBlackhole, 3000);
    
    // Start sucking elements
    startSuckingElements();
    
    // Hide after 30 seconds
    blackholeTimer = setTimeout(() => {
        hideBlackhole();
    }, 30000);
}

// Move black hole around
function moveBlackhole() {
    const maxX = window.innerWidth - 200;
    const maxY = window.innerHeight - 200;
    
    // Generate new position
    blackholeX = Math.random() * maxX;
    blackholeY = Math.random() * maxY;
    
    // Apply with transition
    blackholeContainer.style.left = `${blackholeX}px`;
    blackholeContainer.style.top = `${blackholeY}px`;
}

// Start sucking elements into the black hole
function startSuckingElements() {
    // Elements that can be sucked in
    const suckableElements = document.querySelectorAll('section, .website-card, .floating-image, h1, h2, h3, p:not(.hold-text)');
    
    // Start sucking at random intervals
    const suckInterval = setInterval(() => {
        if (!isBlackholeActive) {
            clearInterval(suckInterval);
            return;
        }
        
        // Find elements that haven't been sucked yet
        const availableElements = Array.from(suckableElements).filter(el => 
            !suckedElements.includes(el) && !el.classList.contains('sucked-in'));
        
        // If all elements are sucked, do nothing
        if (availableElements.length === 0) return;
        
        // Select a random element to suck
        const randomIndex = Math.floor(Math.random() * availableElements.length);
        const elementToSuck = availableElements[randomIndex];
        
        // Add to sucked elements list
        suckedElements.push(elementToSuck);
        
        // Apply sucking effect
        suckElement(elementToSuck);
        
    }, 500); // Try to suck a new element every 500ms
}

// Apply sucking effect to an element
function suckElement(element) {
    // Save original styles for restoration
    const originalStyles = {
        position: element.style.position,
        top: element.style.top,
        left: element.style.left,
        width: element.style.width,
        height: element.style.height,
        transform: element.style.transform,
        opacity: element.style.opacity,
        zIndex: element.style.zIndex
    };
    
    // Store original styles in data attribute
    element.dataset.originalStyles = JSON.stringify(originalStyles);
    
    // Add the sucked-in class
    element.classList.add('sucked-in');
    
    // Apply effects
    element.style.position = 'fixed';
    element.style.zIndex = '9700';
    
    // Calculate the center of the element
    const rect = element.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    // Apply transition to move to black hole
    setTimeout(() => {
        element.style.transform = `translate(${blackholeX + 100 - centerX}px, ${blackholeY + 100 - centerY}px) scale(0.1) rotate(720deg)`;
        element.style.opacity = '0';
    }, 50);
}

// Hide black hole and restore elements
function hideBlackhole() {
    if (!isBlackholeActive) return;
    
    // Hide the container
    blackholeContainer.style.display = 'none';
    
    // Clear intervals and timers
    if (blackholeMoveInterval) {
        clearInterval(blackholeMoveInterval);
        blackholeMoveInterval = null;
    }
    
    if (blackholeTimer) {
        clearTimeout(blackholeTimer);
        blackholeTimer = null;
    }
    
    // Restore all sucked elements
    restoreSuckedElements();
    
    // Reset flags
    isBlackholeActive = false;
    suckedElements = [];
    
    // Schedule next appearance
    scheduleBlackhole();
}

// Restore all elements that were sucked
function restoreSuckedElements() {
    document.querySelectorAll('.sucked-in').forEach(element => {
        // Get original styles
        let originalStyles = {};
        try {
            originalStyles = JSON.parse(element.dataset.originalStyles || '{}');
        } catch (e) {
            console.error('Error parsing original styles', e);
        }
        
        // Remove the class
        element.classList.remove('sucked-in');
        
        // Restore original styles with a fade-in effect
        element.style.transition = 'opacity 1s ease-in';
        
        // Apply original positioning
        element.style.position = originalStyles.position || '';
        element.style.top = originalStyles.top || '';
        element.style.left = originalStyles.left || '';
        element.style.width = originalStyles.width || '';
        element.style.height = originalStyles.height || '';
        element.style.transform = originalStyles.transform || '';
        element.style.zIndex = originalStyles.zIndex || '';
        
        // Fade back in
        setTimeout(() => {
            element.style.opacity = originalStyles.opacity || '1';
        }, 50);
        
        // Clear the data attribute
        delete element.dataset.originalStyles;
    });
}
</script>
</body>
</html>

